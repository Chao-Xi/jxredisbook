
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Jacob's Redis 技术与实战教程">
      
      
        <meta name="author" content="Jacob Xi">
      
      
      <link rel="icon" href="../../images/logo.png">
      <meta name="generator" content="mkdocs-1.2.3, mkdocs-material-8.2.5">
    
    
      
        <title>第七章 Redis Cluster集群介绍及管理 - Jacob Redis Book</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.2d9f7617.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.e6a45f82.min.css">
        
          
          
          <meta name="theme-color" content="#e92063">
        
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="pink" data-md-color-accent="pink">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#redis-cluster" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="Jacob Redis Book" class="md-header__button md-logo" aria-label="Jacob Redis Book" data-md-component="logo">
      
  <img src="../../images/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Jacob Redis Book
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              第七章 Redis Cluster集群介绍及管理
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="清空当前内容" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/Chao-Xi/jxredisbook.git/" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    jxredisbook
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Jacob Redis Book" class="md-nav__button md-logo" aria-label="Jacob Redis Book" data-md-component="logo">
      
  <img src="../../images/logo.png" alt="logo">

    </a>
    Jacob Redis Book
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/Chao-Xi/jxredisbook.git/" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    jxredisbook
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        Welcome
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2">
          第一章 Redis介绍
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="第一章 Redis介绍" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          第一章 Redis介绍
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap1/1redis_intro/" class="md-nav__link">
        第一节 Redis 不得不去掌握的关键
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_3">
          第二章 Redis基础篇
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="第二章 Redis基础篇" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          第二章 Redis基础篇
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap2/1redis_kv/" class="md-nav__link">
        第一节 基本架构： 键值数据库
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap2/2redis_slowquery/" class="md-nav__link">
        第二节 数据结构：Redis为什么那么快？
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap2/3redis_io/" class="md-nav__link">
        第三节 高性能IO模型：Redis为什么那么快？
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap2/4redis_aof_log/" class="md-nav__link">
        第四节 Redis宕机，如何避免数据丢失：AOF日志
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap2/5redis_rdb_snapshot/" class="md-nav__link">
        第五节 Redis宕机，Redis如何实现快速恢复RDB
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap2/6redis_master_slave_replicate/" class="md-nav__link">
        第六节 数据同步：主从库数据一致
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap2/7redis_master_rescue/" class="md-nav__link">
        第七节	哨兵机制：主库不间断服务
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap2/8redis_sentinel/" class="md-nav__link">
        第八节	哨兵集群：哨兵挂了，主从库切换
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap2/9redis_slot/" class="md-nav__link">
        第九节 切片集群：数据增多了，是该加内存还是加实例
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap2/10redis_basic_sum/" class="md-nav__link">
        第二章 Redis核心技术基础总结篇
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" type="checkbox" id="__nav_4" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4">
          第三章 Redis数据结构
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="第三章 Redis数据结构" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          第三章 Redis数据结构
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap3/1redis_string/" class="md-nav__link">
        第一节 Redis的String类型数据结构
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap3/2redis_sets/" class="md-nav__link">
        第二节 Redis有那些数据结构适合做统计
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap3/3redis_geo/" class="md-nav__link">
        第三节 GEO，一种可以实现LBS服务的数据结构
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap3/4redis_timeseries/" class="md-nav__link">
        第四节 根据时间序列数据的特点，选择合适的存储方案
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap3/5redis_stream/" class="md-nav__link">
        第五节 如何使用redis实现消息队列的需求
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap3/6redis_ds_sum/" class="md-nav__link">
        第三章 Redis 的数据结构
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5" type="checkbox" id="__nav_5" >
      
      
      
      
        <label class="md-nav__link" for="__nav_5">
          第四章 Redis性能影响因子
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="第四章 Redis性能影响因子" data-md-level="1">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          第四章 Redis性能影响因子
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap4/1redis_asyn/" class="md-nav__link">
        第一节 Redis有哪些可能导致阻塞的操作
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap4/2redis_cpu/" class="md-nav__link">
        第二节 在多核CPU架构和NUMA架构下对redis进行优化配置
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap4/3redis_response/" class="md-nav__link">
        第三节 当redis查询变慢了怎么办？
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap4/4redis_fragmentation/" class="md-nav__link">
        第四节 删除数据后，内存占用率还是很高
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap4/5redis_buffer/" class="md-nav__link">
        第五节 Redis缓冲区
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap4/6redis_slow_respone/" class="md-nav__link">
        第四章 Redis 影响性能的潜在因素
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_6" type="checkbox" id="__nav_6" >
      
      
      
      
        <label class="md-nav__link" for="__nav_6">
          第五章 Redis缓存介绍
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="第五章 Redis缓存介绍" data-md-level="1">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          第五章 Redis缓存介绍
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap5/1redis_cache/" class="md-nav__link">
        第一节 Redis 旁路缓存
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap5/2redis_cache_full/" class="md-nav__link">
        第二节 缓存满后的替换策略
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap5/3redis_mysql_uncon/" class="md-nav__link">
        第三节 如何解决缓存和数据库的数据不一致的缓存异常
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap5/4redis_contamination/" class="md-nav__link">
        第四节 缓存被污染的解决问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap5/5redis_cache_summary/" class="md-nav__link">
        第五章 Redis 缓存总结
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_7" type="checkbox" id="__nav_7" >
      
      
      
      
        <label class="md-nav__link" for="__nav_7">
          第六章 Redis性能与锁机制以及ACID
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="第六章 Redis性能与锁机制以及ACID" data-md-level="1">
        <label class="md-nav__title" for="__nav_7">
          <span class="md-nav__icon md-icon"></span>
          第六章 Redis性能与锁机制以及ACID
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap6/1redis_pika_ssd/" class="md-nav__link">
        第一节 基于SSD实现大容量Redis:Pika
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap6/2redis_locks/" class="md-nav__link">
        第二节 Redis应对并发访问：无锁的原子操作
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap6/3redis_distributed_locks/" class="md-nav__link">
        第三节 Redis实现分布式锁
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap6/4redis_acid/" class="md-nav__link">
        第四节 事务机制 Redis实现ACID属性
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap6/5redis_perf/" class="md-nav__link">
        第六章 Redis性能与锁机制以及ACID总结
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_8" type="checkbox" id="__nav_8" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_8">
          第七章 Redis Cluster集群介绍及管理
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="第七章 Redis Cluster集群介绍及管理" data-md-level="1">
        <label class="md-nav__title" for="__nav_8">
          <span class="md-nav__icon md-icon"></span>
          第七章 Redis Cluster集群介绍及管理
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../1Redis_master_slave/" class="md-nav__link">
        第一节 Redis主从同步与故障切换的三个坑
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../2redis_brain_split/" class="md-nav__link">
        第二节 脑裂导致数据丢失
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../3redis_codis_cluster/" class="md-nav__link">
        第三节 Redis Codis 集群方案
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../4redis_spike_sys/" class="md-nav__link">
        第四节 Redis支撑秒杀场景的关键技术和实践
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../5redis_data_incline/" class="md-nav__link">
        第五节 数据分布优化应对数据倾斜
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../6redis_cluster_gossip/" class="md-nav__link">
        第六节 限制Redis Cluster规模的关键因素:通信开销
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../8Redis_HA/" class="md-nav__link">
        第七节 Redis 高可用性解决方案
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          第七章 Redis Cluster集群介绍及管理
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        第七章 Redis Cluster集群介绍及管理
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1、本章小结
  </a>
  
    <nav class="md-nav" aria-label="1、本章小结">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-1-redis" class="md-nav__link">
    1-1 Redis主从同步与故障切换的三个坑
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-2" class="md-nav__link">
    1-2 脑裂导致数据丢失
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-3-redis-codis" class="md-nav__link">
    1-3 Redis Codis 集群方案
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-4-redis" class="md-nav__link">
    1-4  Redis支撑秒杀场景的关键技术和实践
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-5" class="md-nav__link">
    1-5 数据分布优化应对数据倾斜
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-6-redis-cluster" class="md-nav__link">
    1-6 限制Redis Cluster规模的关键因素：通信开销
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    2、本章操作总结
  </a>
  
    <nav class="md-nav" aria-label="2、本章操作总结">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#2-1-redis" class="md-nav__link">
    2-1 Redis主从同步与故障切换的三个坑
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-2" class="md-nav__link">
    2-2 脑裂导致数据丢失
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-5" class="md-nav__link">
    2-5 数据分布优化应对数据倾斜
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    3、本章问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    4、常见问题答疑
  </a>
  
    <nav class="md-nav" aria-label="4、常见问题答疑">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#4-1-redis-memcachedrocksdb" class="md-nav__link">
    4-1 Redis 和 Memcached、RocksDB 的对比
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-2-redis-rocksdb" class="md-nav__link">
    4-2 Redis 和 RocksDB 的比较
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_9" type="checkbox" id="__nav_9" >
      
      
      
      
        <label class="md-nav__link" for="__nav_9">
          第八章 Redis学习与操作
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="第八章 Redis学习与操作" data-md-level="1">
        <label class="md-nav__title" for="__nav_9">
          <span class="md-nav__icon md-icon"></span>
          第八章 Redis学习与操作
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap8/1redis_6.0_fea/" class="md-nav__link">
        第一节 Redis 6.0的新特性：多线程、客户端缓存与安全
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap8/2redis_nvm_mem/" class="md-nav__link">
        第二节 Redis 基于NVM内存的实践
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap8/3redis_RESP/" class="md-nav__link">
        第三节 Redis客户端如何与服务器端交换命令和数据 RESP
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap8/4redis_opt_tools/" class="md-nav__link">
        第四节 Redis运维工具
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap8/5redis_protocol/" class="md-nav__link">
        第五节 Redis的使用规范
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap8/8redis_keys/" class="md-nav__link">
        第六节 Redis如何删除数量过万以上Key而不影响业务
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap8/6redis_opt_summary/" class="md-nav__link">
        第八章 Redis学习与操作总结
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap8/7redis_shake/" class="md-nav__link">
        工具补充1：redis-shake数据同步和数据迁移
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_10" type="checkbox" id="__nav_10" >
      
      
      
      
        <label class="md-nav__link" for="__nav_10">
          第九章 使用k8s安装Redis集群
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="第九章 使用k8s安装Redis集群" data-md-level="1">
        <label class="md-nav__title" for="__nav_10">
          <span class="md-nav__icon md-icon"></span>
          第九章 使用k8s安装Redis集群
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap9/1redis_k8s_sts/" class="md-nav__link">
        第一节 Kubernetes上通过sts测试Redis Cluster
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap9/2redis_k8s_config/" class="md-nav__link">
        第二节 利用ConfigMap设置安装 Redis
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_11" type="checkbox" id="__nav_11" >
      
      
      
      
        <label class="md-nav__link" for="__nav_11">
          第十章 期末总结章
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="第十章 期末总结章" data-md-level="1">
        <label class="md-nav__title" for="__nav_11">
          <span class="md-nav__icon md-icon"></span>
          第十章 期末总结章
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap10/1redis_test/" class="md-nav__link">
        Redis 核心技术考题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap10/3Redis_basic/" class="md-nav__link">
        Redis 基础你掌握多少了？来个查漏补缺
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap10/2Redis_interview/" class="md-nav__link">
        40 道Redis面试题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap10/4Redis_int_all/" class="md-nav__link">
        115 道 Redis 面试题解答
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chap10/5redis6_int/" class="md-nav__link">
        Redis6.0与缓存大全基础面试
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1、本章小结
  </a>
  
    <nav class="md-nav" aria-label="1、本章小结">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-1-redis" class="md-nav__link">
    1-1 Redis主从同步与故障切换的三个坑
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-2" class="md-nav__link">
    1-2 脑裂导致数据丢失
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-3-redis-codis" class="md-nav__link">
    1-3 Redis Codis 集群方案
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-4-redis" class="md-nav__link">
    1-4  Redis支撑秒杀场景的关键技术和实践
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-5" class="md-nav__link">
    1-5 数据分布优化应对数据倾斜
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-6-redis-cluster" class="md-nav__link">
    1-6 限制Redis Cluster规模的关键因素：通信开销
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    2、本章操作总结
  </a>
  
    <nav class="md-nav" aria-label="2、本章操作总结">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#2-1-redis" class="md-nav__link">
    2-1 Redis主从同步与故障切换的三个坑
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-2" class="md-nav__link">
    2-2 脑裂导致数据丢失
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-5" class="md-nav__link">
    2-5 数据分布优化应对数据倾斜
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    3、本章问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    4、常见问题答疑
  </a>
  
    <nav class="md-nav" aria-label="4、常见问题答疑">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#4-1-redis-memcachedrocksdb" class="md-nav__link">
    4-1 Redis 和 Memcached、RocksDB 的对比
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-2-redis-rocksdb" class="md-nav__link">
    4-2 Redis 和 RocksDB 的比较
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
<a href="https://github.com/Chao-Xi/jxredisbook.git/edit/master/docs/chap7/7Redis_cluster_summary.md" title="编辑此页" class="md-content__button md-icon">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
</a>



<h1 id="redis-cluster"><strong>第七章 Redis Cluster集群介绍及管理</strong></h1>
<h2 id="1"><strong>1、本章小结</strong></h2>
<h3 id="1-1-redis"><strong>1-1 Redis主从同步与故障切换的三个坑</strong></h3>
<p>Redis 主从库同步时可能出现的 3 个坑，分别是主从数据不一致、读取到过期数据和不合理配置项导致服务挂掉。</p>
<p><img alt="Alt Image Text" src="../../images/chap7_1_3.png" title="Body image" /></p>
<p>关于主从库数据不一致的问题： <strong>Redis 中的 <code>slave-serve-stale-data</code> 配置项设置了从库能否处理数据读写命令，你可以把它设置为 no</strong>。这样一来，从库只能服务 INFO、SLAVEOF 命令，这就可以避免在从库中读到不一致的数据了。</p>
<p><strong>这个配置项和 <code>slave-read-only</code> 的区别，<code>slave-read-only</code> 是设置从库能否处理写命令，<code>slave-read-only</code> 设置为 yes 时，从库只能处理读请求，无法处理写请求，你可不要搞混了。</strong></p>
<h3 id="1-2"><strong>1-2 脑裂导致数据丢失</strong></h3>
<p>脑裂是指在主从集群中，同时有两个主库都能接收写请求。在 Redis 的主从切换过程中，如果发生了脑裂，客户端数据就会写入到原主库，如果原主库被降为从库，这些新写入的数据就丢失了。</p>
<p>脑裂发生的原因主要是原主库发生了假故障，总结下假故障的两个原因。</p>
<ol>
<li><strong>和主库部署在同一台服务器上的其他程序临时占用了大量资源（例如 CPU 资源），导致主库资源使用受限，短时间内无法响应心跳</strong>。其它程序不再使用资源时，主库又恢复正常。</li>
<li>主库自身遇到了阻塞的情况，例如，处理 bigkey 或是发生内存 swap，短时间内无法响应心跳，等主库阻塞解除后，又恢复正常的请求处理了。</li>
</ol>
<p>为了应对脑裂，可以在主从集群部署时，通过合理地配置参数 <code>min-slaves-to-write</code> 和 <code>min-slaves-max-lag</code>，来预防脑裂的发生。</p>
<p>在实际应用中，可能会因为网络暂时拥塞导致从库暂时和主库的 ACK 消息超时。在这种情况下，并不是主库假故障，我们也不用禁止主库接收请求。</p>
<p><strong><span style="color:red">建议是，假设从库有 K 个，可以将 <code>min-slaves-to-write</code> 设置为<code>K/2+1</code>（如果 K 等于 1，就设为 1），将 <code>min-slaves-max-lag</code> 设置为十几秒（例如 10～20s），在这个配置下，如果有一半以上的从库和主库进行的 ACK 消息延迟超过十几秒，我们就禁止主库接收客户端写请求</span></strong>。</p>
<p>避免脑裂带来数据丢失的情况，而且，也不会因为只有少数几个从库因为网络阻塞连不上主库，就禁止主库接收请求，增加了系统的鲁棒性。</p>
<h3 id="1-3-redis-codis"><strong>1-3 Redis Codis 集群方案</strong></h3>
<p>Codis 集群包含 codis server、codis proxy、Zookeeper、codis dashboard 和 codis fe 这四大类组件。</p>
<ul>
<li>codis proxy 和 codis server 负责处理数据读写请求，其中，codis proxy 和客户端连接，接收请求，并转发请求给 codis server，而 codis server 负责具体处理请求。</li>
<li>codis dashboard 和 codis fe 负责集群管理，其中，codis dashboard 执行管理操作，而 codis fe 提供 Web 管理界面。</li>
<li>Zookeeper 集群负责保存集群的所有元数据信息，包括路由表、proxy 实例信息等。这里，有个地方需要你注意，除了使用 Zookeeper，Codis 还可以使用 etcd 或本地文件系统保存元数据信息。</li>
</ul>
<p>关于 Codis 和 Redis Cluster 的选型考虑，从稳定性成熟度、客户端兼容性、Redis 新特性使用以及数据迁移性能四个方面给你提供了建议。</p>
<p>我再给你提供一个 Codis 使用上的小建议：<strong>当你有多条业务线要使用 Codis 时，可以启动多个 codis dashboard，每个 dashboard 管理一部分 codis server，同时，再用一个 dashboard 对应负责一个业务线的集群管理，这样，就可以做到用一个 Codis 集群实现多条业务线的隔离管理了</strong>。</p>
<h3 id="1-4-redis"><strong>1-4  Redis支撑秒杀场景的关键技术和实践</strong></h3>
<p>秒杀场景有 2 个负载特征，分别是瞬时<strong>高并发请求和读多写少</strong>。Redis 良好的高并发处理能力，以及高效的键值对读写特性，正好可以满足秒杀场景的需求。</p>
<p>在秒杀场景中，我们可以通过前端 CDN 和浏览器缓存拦截大量秒杀前的请求。在实际秒杀活动进行时，库存查验和库存扣减是承受巨大并发请求压力的两个操作，同时，这两个操作的执行需要保证原子性。Redis 的原子操作、分布式锁这两个功能特性可以有效地来支撑秒杀场景的需求。</p>
<p>当然，对于秒杀场景来说，只用 Redis 是不够的。秒杀系统是一个系统性工程，Redis 实现了对库存查验和扣减这个环节的支撑，除此之外，还有 4 个环节需要我们处理好。</p>
<ol>
<li><strong>前端静态页面的设计</strong>。秒杀页面上能静态化处理的页面元素，我们都要尽量静态化，这样可以充分利用 CDN 或浏览器缓存服务秒杀开始前的请求。</li>
<li><strong>请求拦截和流控</strong>。在秒杀系统的接入层，对恶意请求进行拦截，避免对系统的恶意攻击，例如使用黑名单禁止恶意 IP 进行访问。如果 Redis 实例的访问压力过大，为了避免实例崩溃，我们也需要在接入层进行限流，控制进入秒杀系统的请求数量。</li>
<li><strong>库存信息过期时间处理</strong>。Redis 中保存的库存信息其实是数据库的缓存，为了避免缓存击穿问题，我们不要给库存信息设置过期时间。</li>
<li><strong>数据库订单异常处理</strong>。如果数据库没能成功处理订单，可以增加订单重试功能，保证订单最终能被成功处理。</li>
</ol>
<p>建议：<strong>秒杀活动带来的请求流量巨大，我们需要把秒杀商品的库存信息用单独的实例保存，而不要和日常业务系统的数据保存在同一个实例上，这样可以避免干扰业务系统的正常运行。</strong></p>
<h3 id="1-5"><strong>1-5 数据分布优化应对数据倾斜</strong></h3>
<p><strong>数据倾斜的两种情况：数据量倾斜和数据访问倾斜。</strong></p>
<p>造成数据量倾斜的原因主要有三个：</p>
<ol>
<li>数据中有 bigkey，导致某个实例的数据量增加；</li>
<li>Slot 手工分配不均，导致某个或某些实例上有大量数据；</li>
<li>使用了 Hash Tag，导致数据集中到某些实例上。</li>
</ol>
<p>而数据访问倾斜的主要原因就是<strong>有热点数据存在，导致大量访问请求集中到了热点数据所在的实例上。</strong></p>
<p>为了应对数据倾斜问题，四个方法，</p>
<p><img alt="Alt Image Text" src="../../images/chap7_5_4.png" title="Body image" /></p>
<p><strong>如果已经发生了数据倾斜，我们可以通过数据迁移来缓解数据倾斜的影响。Redis Cluster 和 Codis 集群都提供了查看 Slot 分配和手工迁移 Slot 的命令，你可以把它们应用起来。</strong></p>
<p>关于集群的实例资源配置，一个小建议：<strong><span style="color:red">在构建切片集群时，尽量使用大小配置相同的实例（例如实例内存配置保持相同），这样可以避免因实例资源不均衡而在不同实例上分配不同数量的 Slot。</span></strong></p>
<h3 id="1-6-redis-cluster"><strong>1-6 限制Redis Cluster规模的关键因素：通信开销</strong></h3>
<p>Redis Cluster 实例间以 Gossip 协议进行通信的机制。Redis Cluster 运行时，各实例间需要通过 PING、PONG 消息进行信息交换，这些心跳消息包含了当前实例和部分其它实例的状态信息，以及 Slot 分配信息。这种通信机制有助于 Redis Cluster 中的所有实例都拥有完整的集群状态信息。</p>
<p>但是，随着集群规模的增加，实例间的通信量也会增加。<strong>如果我们盲目地对 Redis Cluster 进行扩容，就可能会遇到集群性能变慢的情况。这是因为，集群中大规模的实例间心跳消息会挤占集群处理正常请求的带宽。而且，有些实例可能因为网络拥塞导致无法及时收到 PONG 消息，每个实例在运行时会周期性地（每秒 10 次）检测是否有这种情况发生，一旦发生，就会立即给这些 PONG 消息超时的实例发送心跳消息</strong>。</p>
<p><strong><span style="color:red">集群规模越大，网络拥塞的概率就越高，相应的，PONG 消息超时的发生概率就越高，这就会导致集群中有大量的心跳消息，影响集群服务正常请求。</span></strong></p>
<p>建议，虽然我们可以通过调整 <code>cluster-node-timeout</code> 配置项减少心跳消息的占用带宽情况，但是，<strong>在实际应用中，如果不是特别需要大容量集群，我建议你把 Redis Cluster 的规模控制在 400~500 个实例。</strong></p>
<p>假设单个实例每秒能支撑 8 万请求操作（8 万 QPS），每个主实例配置 1 个从实例，那么，<code>400~ 500</code> 个实例可支持 <code>1600 万~2000</code> 万 QPS（<code>200/250 个主实例 *8 万 QPS=1600/2000 万 QPS</code>），这个吞吐量性能可以满足不少业务应用的需求。</p>
<h2 id="2"><strong>2、本章操作总结</strong></h2>
<h3 id="2-1-redis"><strong>2-1 Redis主从同步与故障切换的三个坑</strong></h3>
<p>第一个例子是使用 EXPIRE 命令，当执行下面的命令时，<strong>我们就把 testkey 的过期时间设置为 60s 后。</strong></p>
<pre><code>EXPIRE testkey 60
</code></pre>
<p>第二个例子是使用 <code>EXPIREAT</code> 命令，例如，我们执行下面的命令，<strong>就可以让 testkey 在 2020 年 10 月 24 日上午 9 点过期，命令中的 1603501200 就是以秒数时间戳表示的 10 月 24 日上午 9 点</strong></p>
<pre><code>EXPIREAT testkey 1603501200
</code></pre>
<p><strong>protected-mode 配置项</strong></p>
<p>在应用主从集群时，要注意将 protected-mode 配置项设置为 no，并且将 bind 配置项设置为其它哨兵实例的 IP 地址。 只有在 bind 中设置了 IP 地址的哨兵，才可以访问当前实例，既保证了实例间能够通信进行主从切换，也保证了哨兵的安全性。</p>
<p>如果设置了下面的配置项，那么，部署在 192.168.10.3/4/5 这三台服务器上的哨兵实例就可以相互通信，执行主从切换。</p>
<pre><code>protected-mode no
bind 192.168.10.3 192.168.10.4 192.168.10.5
</code></pre>
<h3 id="2-2"><strong>2-2 脑裂导致数据丢失</strong></h3>
<p><strong>Redis 已经提供了两个配置项来限制主库的请求处理，分别是 <code>min-slaves-to-write</code> 和 <code>min-slaves-max-lag</code></strong>。</p>
<ul>
<li><code>min-slaves-to-write</code>：这个配置项设置了<strong>主库能进行数据同步的最少从库数量</strong>；</li>
<li><code>min-slaves-max-lag</code>：这个配置项设置了<strong>主从库间进行数据复制时，从库给主库发送 ACK 消息的最大延迟（以秒为单位）</strong>。</li>
</ul>
<p>可以把 <code>min-slaves-to-write</code> 和 <code>min-slaves-max-lag</code> 这两个配置项搭配起来使用，分别给它们设置一定的阈值，假设为 <code>N</code> 和<code>T</code>。</p>
<ul>
<li>假设我们将 <code>min-slaves-to-write</code> 设置为 1</li>
<li>把 <code>min-slaves-max-lag</code> 设置为 12s</li>
<li>把哨兵的 <code>down-after-milliseconds</code>设置为 10s</li>
</ul>
<h3 id="2-5"><strong>2-5 数据分布优化应对数据倾斜</strong></h3>
<p>比如说，我们执行 <code>CLUSTER SLOTS</code> 命令查看 Slot 分配情况。<strong>命令返回结果显示，<code>Slot 0</code> 到 <code>Slot 4095</code> 被分配到了实例 <code>192.168.10.3</code> 上，而 <code>Slot 12288</code> 到 <code>Slot 16383</code> 被分配到了实例 <code>192.168.10.5</code> 上。</strong></p>
<pre><code>127.0.0.1:6379&gt; cluster slots
1) 1) (integer) 0
   2) (integer) 4095
   3) 1) &quot;192.168.10.3&quot;
      2) (integer) 6379
2) 1) (integer) 12288
   2) (integer) 16383
   3) 1) &quot;192.168.10.5&quot;
      2) (integer) 6379
</code></pre>
<p>如果某一个实例上有太多的 Slot，就可以使用迁移命令把这些 Slot 迁移到其它实例上。<strong>在 Redis Cluster 中，我们可以使用 3 个命令完成 Slot 迁移。</strong></p>
<ol>
<li><code>CLUSTER SETSLOT</code>：使用不同的选项进行三种设置，分别是设置 Slot 要迁入的目标实例，Slot 要迁出的源实例，以及 Slot 所属的实例。</li>
<li><code>CLUSTER GETKEYSINSLOT</code>：<strong>获取某个 Slot 中一定数量的 key</strong>。</li>
<li><code>MIGRATE</code>：把一个 key 从源实例实际迁移到目标实例。
4
假设我们要把 Slot 300 从源实例（ID 为 3）迁移到目标实例（ID 为 5），那要怎么做呢？</li>
</ol>
<p>实际上，可以分成 5 步。</p>
<ul>
<li>第 1 步，先<strong>在目标实例 5 上执行下面的命令</strong>，<strong>将 Slot 300 的源实例设置为实例 3，表示要从实例 3 上迁入 Slot 300。</strong></li>
</ul>
<pre><code>CLUSTER SETSLOT 300 IMPORTING 3
</code></pre>
<ul>
<li>第 2 步，<strong>在源实例 3 上，我们把 Slot 300 的目标实例设置为 5，这表示，Slot 300 要迁出到实例 5 上</strong>，如下所示：</li>
</ul>
<pre><code>CLUSTER SETSLOT 300 MIGRATING 5
</code></pre>
<ul>
<li>第 3 步，<strong>从 Slot 300 中获取 100 个 key。因为 Slot 中的 key 数量可能很多，所以我们需要在客户端上多次执行下面的这条命令，分批次获得并迁移 key</strong>。</li>
</ul>
<pre><code>CLUSTER GETKEYSINSLOT 300 100
</code></pre>
<ul>
<li>第 4 步，我们把刚才获取的 100 个 key 中的 key1 迁移到目标实例 5 上（IP 为 192.168.10.5），<strong>同时把要迁入的数据库设置为 0 号数据库</strong>，<strong>把迁移的超时时间设置为 timeout。我们重复执行 MIGRATE 命令，把 100 个 key 都迁移完</strong>。</li>
</ul>
<pre><code>MIGRATE 192.168.10.5 6379 key1 0 timeout
</code></pre>
<p>最后，我们重复执行第 3 和第 4 步，直到 Slot 中的所有 key 都迁移完成。</p>
<p>从 Redis 3.0.6 开始，你也可以使用 KEYS 选项，一次迁移多个 key（key1、2、3），这样可以提升迁移效率。</p>
<pre><code>MIGRATE 192.168.10.5 6379 &quot;&quot; 0 timeout KEYS key1 key2 key3
</code></pre>
<p>对于 Codis 来说，我们可以执行下面的命令进行数据迁移。其中，我们把 dashboard 组件的连接地址设置为 ADDR，并且把 Slot 300 迁移到编号为 6 的 codis server group 上。</p>
<pre><code>codis-admin --dashboard=ADDR -slot-action --create --sid=300 --gid=6
</code></pre>
<h2 id="3"><strong>3、本章问题</strong></h2>
<p><strong>3-1 问题：</strong>在主从集群中，我们把 <code>slave-read-only</code> 设置为 no，让从库也能直接删除数据，以此来避免读到过期数据。你觉得，这是一个好方法吗？</p>
<p>假设从库也能直接删除过期数据的话（也就是执行写操作），是不是一个好方法？其实，我是想借助这道题目提醒你，<strong>主从复制中的增删改操作都需要在主库执行，即使从库能做删除，也不要在从库删除，否则会导致数据不一致。</strong></p>
<p>例如，主从库上都有 <code>a:stock</code> 的键，客户端 A 给主库发送一个 SET 命令，修改 <code>a:stock</code> 的值，客户端 B 给从库发送了一个 SET 命令，也修改 <code>a:stock</code> 的值，此时，相同键的值就不一样了。<strong>所以，如果从库具备执行写操作的功能，就会导致主从数据不一致。</strong></p>
<p><strong>即使从库可以删除过期数据，也还会有不一致的风险，有两种情况。</strong></p>
<p>第一种情况是，对于已经设置了过期时间的 key，主库在 key 快要过期时，使用 expire 命令重置了过期时间，例如，一个 key 原本设置为 10s 后过期，在还剩 1s 就要过期时，主库又用 expire 命令将 key 的过期时间设置为 60s 后。但是，expire 命令从主库传输到从库时，由于网络延迟导致从库没有及时收到 expire 命令（比如延后了 3s 从库才收到 expire 命令），所以，从库按照原定的过期时间删除了过期 key，这就导致主从数据不一致了。</p>
<p>第二种情况是，主从库的时钟不同步，导致主从库删除时间不一致。</p>
<p><strong>另外，当 <code>slave-read-only</code> 设置为 no 时，如果在从库上写入的数据设置了过期时间，Redis 4.0 前的版本不会删除过期数据，而 Redis 4.0 及以上版本会在数据过期后删除。</strong>但是，对于主库同步过来的带有过期时间的数据，从库仍然不会主动进行删除。</p>
<p><strong>3-2 问题：</strong>假设我们将 <code>min-slaves-to-write</code> 设置为 1，<code>min-slaves-max-lag</code> 设置为 15s，哨兵的 <code>down-after-milliseconds</code> 设置为 10s，哨兵主从切换需要 5s，而主库因为某些原因卡住了 12s。此时，还会发生脑裂吗？主从切换完成后，数据会丢失吗？</p>
<ul>
<li>主库卡住了 12s，超过了哨兵的 <code>down-after-milliseconds 10s</code> 阈值，所以，<strong>哨兵会把主库判断为客观下线，开始进行主从切换</strong>。</li>
<li>因为主从切换需要 5s，在主从切换过程中，原主库恢复正常。</li>
<li><code>min-slaves-max-lag</code> 设置的是 15s，而原主库在卡住 12s 后就恢复正常了<strong>，所以没有被禁止接收请求，客户端在原主库恢复后，又可以发送请求给原主库</strong>。</li>
<li><strong>一旦在主从切换之后有新主库上线，就会出现脑裂</strong>。如果原主库在恢复正常后到降级为从库前的这段时间内，<strong>接收了写操作请求，那么，这些数据就会丢失了</strong>。</li>
</ul>
<p><strong>3-3 问题</strong>：假设 Codis 集群中保存的 80% 的键值对都是 Hash 类型，每个 Hash 集合的元素数量在 10 万~20 万个，每个集合元素的大小是 2KB。你觉得，迁移这样的 Hash 集合数据，会对 Codis 的性能造成影响吗？</p>
<p>答案：其实影响不大。虽然一个 Hash 集合数据的总数据量有 <code>200MB ~ 400MB（2KB * 0.1M ≈ 200MB 到 2KB * 0.2M ≈ 400MB）</code>，但是 Codis 支持异步、分批迁移数据，所以，Codis 可以把集合中的元素分多个批次进行迁移，每批次迁移的数据量不大，所以，不会给源实例造成太大影响。</p>
<p><strong>3-4 问题</strong>：假设一个商品的库存量是 800，我们使用一个包含了 4 个实例的切片集群来服务秒杀请求，我们让每个实例各自维护库存量 200，把客户端的秒杀请求分发到不同的实例上进行处理，你觉得这是一个好方法吗？</p>
<p>答案：这个方法是不是能达到一个好的效果，主要取决于，<strong>客户端请求能不能均匀地分发到每个实例上</strong>。如果可以的话，那么，每个实例都可以帮着分担一部分压力，避免压垮单个实例。</p>
<p>在保存商品库存时，key 一般就是商品的 ID，所以，客户端在秒杀场景中查询同一个商品的库存时，会向集群请求相同的 key，集群就需要把客户端对同一个 key 的请求均匀地分发到多个实例上。</p>
<p><strong>为了解决这个问题，客户端和实例间就需要有代理层来完成请求的转发。</strong>例如，在 Codis 中，codis proxy 负责转发请求，那么，如<strong>果我们让 codis proxy 收到请求后，按轮询的方式把请求分发到不同实例上（可以对 Codis 进行修改，增加转发规则），就可以利用多实例来分担请求压力了</strong>。</p>
<p>为了解决这个问题，客户端和实例间就需要有代理层来完成请求的转发。<strong>例如，在 Codis 中，codis proxy 负责转发请求，那么，如果我们让 codis proxy 收到请求后</strong>，按轮询的方式把请求分发到不同实例上（可以对 Codis 进行修改，增加转发规则），就可以利用多实例来分担请求压力了。</p>
<p><strong>3-5 问题：</strong>当有数据访问倾斜时，如果热点数据突然过期了，假设 Redis 中的数据是缓存，数据的最终值是保存在后端数据库中的，这样会发生什么问题吗?</p>
<p>答案：在这种情况下，<strong>会发生缓存击穿的问题，也就是热点数据突然失效，导致大量访问请求被发送到数据库，给数据库带来巨大压力</strong>。</p>
<p>我们可以采用<a href="https://chao-xi.github.io/jxredisbook/chap5/5redis_cache_summary/#1-3">如何解决缓存和数据库的数据不一致的缓存异常</a>介绍的方法，<strong>不给热点数据设置过期时间，这样可以避免过期带来的击穿问题。</strong></p>
<p>除此之外，<strong>我们最好在数据库的接入层增加流控机制，一旦监测到有大流量请求访问数据库，立刻开启限流，这样做也是为了避免数据库被大流量压力压垮</strong>。因为数据库一旦宕机，就会对整个业务应用带来严重影响。所以，我们宁可在请求接入数据库时，就直接拒接请求访问。</p>
<p><strong>3-6 问题：</strong> 如果我们采用跟 Codis 保存 Slot 分配信息相类似的方法，把集群实例状态信息和 Slot 分配信息保存在第三方的存储系统上（例如 Zookeeper），这种方法会对集群规模产生什么影响吗？</p>
<p>答案：假设我们将 Zookeeper 作为第三方存储系统，保存集群实例状态信息和 Slot 分配信息，那么，实例只需要和 Zookeeper 通信交互信息，实例之间就不需要发送大量的心跳消息来同步集群状态了。这种做法可以减少实例之间用于心跳的网络通信量，有助于实现大规模集群。而且，网络带宽可以集中用在服务客户端请求上。</p>
<p>不过，在这种情况下，实例获取或更新集群状态信息时，都需要和 Zookeeper 交互，Zookeeper 的网络通信带宽需求会增加。所以，采用这种方法的时候，需要给 Zookeeper 保证一定的网络带宽，避免 Zookeeper 受限于带宽而无法和实例快速通信。</p>
<h2 id="4"><strong>4、常见问题答疑</strong></h2>
<h3 id="4-1-redis-memcachedrocksdb"><strong>4-1 Redis 和 Memcached、RocksDB 的对比</strong></h3>
<p><strong>Memcached 和 RocksDB 分别是典型的内存键值数据库和硬盘键值数据库</strong>，应用得也非常广泛。和 Redis 相比，它们有什么优势和不足呢？是否可以替代 Redis 呢？我们来聊一聊这个问题。</p>
<p><strong>Redis 和 Memcached 的比较</strong></p>
<p>和 Redis 相似，Memcached 也经常被当做缓存来使用。<strong>不过，Memcached 有一个明显的优势，就是它的集群规模可以很大。</strong></p>
<p>Memcached 集群并不是像 Redis Cluster 或 Codis 那样，使用 Slot 映射来分配数据和实例的对应保存关系，<strong>而是使用一致性哈希算法把数据分散保存到多个实例上，而一致性哈希的优势就是可以支持大规模的集群</strong>。所以，如果我们需要部署大规模缓存集群，Memcached 会是一个不错的选择。</p>
<p>不过，在使用 Memcached 时，有个地方需要注意，Memcached 支持的数据类型比 Redis 少很多。<strong>Memcached 只支持 String 类型的键值对，而 Redis 可以支持包括 String 在内的多种数据类型，当业务应用有丰富的数据类型要保存的话，使用 Memcached 作为替换方案的优势就没有了。</strong></p>
<p>如果你既需要保存多种数据类型，又希望有一定的集群规模保存大量数据，那么，Redis 仍然是一个不错的方案。</p>
<p><img alt="Alt Image Text" src="../../images/chap7_7_1.png" title="Body image" /></p>
<h3 id="4-2-redis-rocksdb"><strong>4-2 Redis 和 RocksDB 的比较</strong></h3>
<p>和 Redis 不同，<strong>RocksDB 可以把数据直接保存到硬盘上。这样一来，单个 RocksDB 可以保存的数据量要比 Redis 多很多，而且数据都能持久化保存下来</strong>。</p>
<p>除此之外，<strong>RocksDB 还能支持表结构（即列族结构），而 Redis 的基本数据模型就是键值对</strong>。所以，如果你需要一个大容量的持久化键值数据库，并且能按照一定表结构保存数据，RocksDB 是一个不错的替代方案。</p>
<p>不过，RocksDB 毕竟是要把数据写入底层硬盘进行保存的，而且在进行数据查询时，如果 RocksDB 要读取的数据没有在内存中缓存，那么，RocksDB 就需要到硬盘上的文件中进行查找，这会拖慢 RocksDB 的读写延迟，降低带宽。</p>
<p><strong>在性能方面，RocksDB 是比不上 Redis 的。</strong>而且，RocksDB 只是一个动态链接库，并没有像 Redis 那样提供了客户端 - 服务器端访问模式，以及主从集群和切片集群的功能。所以，我们在使用 RocksDB 替代 Redis 时，需要结合业务需求重点考虑替换的可行性。</p>
<p><img alt="Alt Image Text" src="../../images/chap7_7_2.png" title="Body image" /></p>
<p>集群部署和运维涉及的工作量非常大，所以，我们一定要重视集群方案的选择。</p>
<p><strong>集群的可扩展性是我们评估集群方案的一个重要维度</strong>，集群中元数据是用 Slot 映射表，还是一致性哈希维护的。如果是 Slot 映射表，那么，是用中心化的第三方存储系统来保存，还是由各个实例来扩散保存，这也是需要考虑清楚的。Redis Cluster、Codis 和 Memcached 采用的方式各不相同。</p>
<ul>
<li><strong>Redis Cluster：使用 Slot 映射表并由实例扩散保存</strong>。</li>
<li><strong>Codis：使用 Slot 映射表并由第三方存储系统保存。</strong></li>
<li>Memcached：使用一致性哈希。</li>
</ul>

              
            </article>
          </div>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="页脚">
      
        
        <a href="../8Redis_HA/" class="md-footer__link md-footer__link--prev" aria-label="上一页: 第七节 Redis 高可用性解决方案" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                上一页
              </span>
              第七节 Redis 高可用性解决方案
            </div>
          </div>
        </a>
      
      
        
        <a href="../../chap8/1redis_6.0_fea/" class="md-footer__link md-footer__link--next" aria-label="下一页: 第一节 Redis 6.0的新特性：多线程、客户端缓存与安全" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                下一页
              </span>
              第一节 Redis 6.0的新特性：多线程、客户端缓存与安全
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2021-9999 Jacob Xi
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../..", "features": [], "translations": {"clipboard.copy": "\u590d\u5236", "clipboard.copied": "\u5df2\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\uff0c\\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.term.missing": "\u7f3a\u5c11", "select.version.title": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "search": "../../assets/javascripts/workers/search.bd0b6b67.min.js"}</script>
    
    
      <script src="../../assets/javascripts/bundle.467223ff.min.js"></script>
      
    
  </body>
</html>