# **Redis 核心技术考题**

## **1、期中选择题**

1.Redis的Streams数据类型可以用来实现消息队列，关于Streams，下列哪个描述是**不正确**的？ 

* Streams可以为消息自动生成全局唯一ID 
* Streams会自动留存消息，直到消费者使用XACK确认后，再删除消息 
* Streams支持阻塞式消息读取 
* **<span style="color:red">Streams提供的消费组模式，同一个消费组内的消费者可以同时消费同一条消息</span>**

> 需要注意的是，消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了。


2.Redis运行的过程中，运维人员通过info memory 查看到`mem_fragmentation_ratio`的值等于2, Redis的内存使用情况是怎样的？ 

* **<span style="color:red">内存使用中存在较为严重的内存碎片</span>** 
* 内存空间不够，可能已经发生了swap 
* 内存使用正常，有少量内存碎片 
* 内存非常充足，可以保存更多的数据 

> `mem_fragmentation_ratio`大于 1.5。这表明内存碎片率已经超过了 50%。一般情况下，这个时候，我们就需要采取一些措施来降低内存碎片率了。

3.在Redis中，默认的内存分配器使用的是jemalloc，当 Redis想要分配23字节的空间时，jemalloc实际会分配多大空间？ 

* 23
* 24
* **<span style="color:red">32</span>**
* 64

> jemalloc 在分配内存时，会根据我们申请的字节数 N，找一个比 N 大，但是最接近 N 的 2 的幂次数作为分配的空间，这样可以减少频繁分配的次数。


4.Redis使用RDB机制创建快照，关于RDB机制，下面的描述哪个是错误的？ 

* 使用save命令生成RDB快照时，是在主线程中执行的，会阻塞主线程 
* RDB文件是Redis实例的镜像，用RDB 文件恢复实例时，直接把RDB文件加载到内存， 就可以快速恢复了 
* 和AOF文件相比，RDB文件更小一点 
* **<span style="color:red">使用bgsave命令创建RDB快照时，主线程只能处理读请求，写请求操作会被阻塞 2</span>**

> bgsave 创建快照时，主线程能同时处理读写请求

5.Redis使用AOF机制保存数据操作时，可以采用不同的写回策略。**当需要有一定的数据可靠性，同时也不能对Redis实例造成较大阻塞的话**，应该选择以下哪种写回策略？ 

* always 
* **<span style="color:red">everysec</span>**
* no 
* yes 

> 使用everysec时，会使用子线程来操作，不会阻塞主线程。而使用always时，是使用主线程来操作，所以会阻塞主线程
> 
> 选项A，可靠性高，但会阻塞Redis实例 
> 
> 选项C，基本不会阻塞Redis实例，但是宕机后，会丢失较多的日志记录 
> 
> 选项D，写回策略没有yes配置项 

6.现在，有一个Redis实例正在线上运行，**它使用Hash类型保存了一个key为device的Hash集合**，集合中保存了500万条记录。在这些记录中，有20万条记录的key是以“redis”开头的，现在想把这些记录读取出来，应该采用以下哪些命令？ 

* KEYS 
* SCAN 
* **<span style="color:red">HSCAN</span>**
* SSCAN 

> 选项A, KEYS 会引起Redis实例阻塞，而且KEYS无法查询日ash集合中的记录 
> 
> 选项B, **SCAN只能查询整个数据库中的key**
> 
> 选项D, **SSCAN是用来扫描查询Set类型**


7.在主从集群中，当主库收到从库发送的`psync?-1`命令 时，从库希望主库执行的操作是以下哪一项？ 

* 进行增量复制 
* 结束数据复制操作 
* 断开网络连接 
* **<span style="color:red">进行全量复制</span>** 

> 选项A，增量复制时，从库会把自己记录的主库ID发给主库，所以psync命令会带有主库ID 
> 
> 选项B，不会发送psync 
> 
> 选项C，不会发送psync 
> 
> **第一阶段是主从库间建立连接、协商同步的过程，主要是为全量复制做准备`psync?-1`**


8.关于哨兵机制，下面的哪个描述是正确的？ 

* 哨兵是一个运行在特定模式下的Redis实例，也可以服务请求 
* **<span style="color:red">哨兵提供pub/sub功能</span>**  
* 哨兵只通过心跳监听主库的运行状态 
* `down-after-milliseconds`是哨兵用来判断主库客观下线的心跳断连阈值

**通过 pub/sub 机制，哨兵之间可以组成集群，同时，哨兵又通过 INFO 命令，获得了从库连接信息，也能和从库建立连接，并进行监控了。**

> 选项A，哨兵不服务请求 
> 
> 选项C，哨兵同时监听从库的运行状态 

> 选项D, **down-after-milliseconds是主观下线的判断依据**

* 哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接情况，用来判断实例的状态。
* 在判断主库是否下线时，不能由一个哨兵说了算，只有大多数的哨兵实例，都判断主库已经“主观下线”了，主库才会被标记为“客观下线”，这个叫法也是表明主库下线成为一个客观事实了
* **如果在 down-after-milliseconds 毫秒内，主从节点都没有通过网络联系上，我们就可以认为主从节点断连了。**

9.在使用哨兵机制对发生故障的主从集群进行主从库切 时，会涉及： 

* (1) 主库被判断为主观下线； 
* (2）主库被判断为客观下线； 
* (3）确定新主库；
* (4）选举哨兵Leader; 
* (5）主从库实际切换。 关于这些事件的发生顺序，以下哪个选项的描述是正确的？ 

* (1）一＞(2）一＞(3）一＞(4)一＞(5) 
* (2）一＞(1）一＞(3）一＞>(4)一＞(5) 
* **<span style="color:red">(1）一＞(2）一＞(4)一＞(3）一＞(5) </span>**  
* (2）一＞>(1）一＞>(4)一＞(3）一＞(5) 

> 主库的主观下线只用哨兵自己判断就行，而客观下线需要多个哨兵共同决定，所以判断主库主观下线要早于判断客观下线。 主从库切换时，新主库是由哨兵Leader来确定的，所以，哨兵集群需要先选出Leader，再确定新主库。 


10.在一个由5个哨兵组成的哨兵集群中，配置文件中的quorum值配置为4，那么，当有峭兵发现主节点故障，开始进行Leader选举时，这个峭兵需要获得几张赞成票， 才能成功地成为Leader? 

* 2
* 3
*  **<span style="color:red">4</span>**  
* 5

>  哨兵Leader选举需要满足两个条件：**一是要拿到半数以上的赞成票；二是，拿到的票数同时还需要大于等于哨兵配置文件中的quorum值，本题中的quorum值设为4，所以 至少要获得4张赞成票**。 

11.在使用Redis Cluster时，**如果客户端发送操作请求后**， 收到了MOVED命令，此时，Redis Cluster发生了以下 哪种情况？ 

* 请求的数据在Cluster中已经被删除 
* 请求数据所在的哈希槽正在往其他实例迁移 
* **<span style="color:red">请求数据所在的哈希槽已经迁移到了其他实例</span>**  
* 请求的数据正在持久化保存 

> A选项，此时返回nil值
>  
> B选项，此时返回ASK报错信息
> 
> D选项，不会报错，可以正常返回结果 

12.在Redis的诸多数据类型中，以下哪种数据类型允许插入 重复的元素？ 

* HyperLogLog 
* **<span style="color:red">List</span>**
* Set 
* Sorted Set 

> 选项A，会对元素去重 
> 
> 选项B，正确，允许写入重复元素 
> 
> 选项C，会对元素去重 
> 
> 选项D，会对元素去重 

**HyperLogLog 是一种用于统计基数的数据集合类型，它的最大优势就在于，当集合元素数量非常多时，它计算基数所需的空间总是固定的，而且还很小。**

13.Redis数据库是将下列哪种数据结构作为**全局数据结构**来保存每一对键值对？ 

* 数组 
* **<span style="color:red">哈希表</span>**
* 跳表 
* 双向链表 


> 题目问的是Redis数据库的全局数据结构，所以选B。其他选项是Redis某一个数据类型的底层数据结构 

14.在Redis的主从库集群中，如果主库宕机了，以下哪个**机制可以让Redis实现自动的主从库切换**？ 

* AOF重写机制 
* RDB机制 
* 切片机制
* **<span style="color:red">哨兵机制</span>** 

> A选项，**<span style="color:red">AOF重写用来精简过大的AOF文件，加速Redis实例恢复。</span>**  
> 
> B选项， **<span style="color:red">RDB机制用来生成快照，用于实例恢复或是主从库复制。</span>**  
> 
> 
> C选项， **<span style="color:red">切片机制是把数据分散到多个实例保存，用于保存大量数据。</span>**  

15.以下哪个功能是由Redis主线程完成的？ 

*  **<span style="color:red">键值对读写</span>** 
* UNLINK操作 
* 生成RDB快照 
* AOF重写 

**异步的子线程机制 键值对删除 当你的集合类型中有大量元素（例如有百万级别或千万级别元素）需要删除时，我建议你使用 UNLINK 命令**

> B选项， **<span style="color:red">UNLINK操作是Redis 4.0后提供的后台异步删除操作，由后台子线程完成。</span>**  
> 
> C选项，**<span style="color:red">RDB生成是主线程通过fork创建了子进程来完成的。</span>**   
> 
> D选项，**<span style="color:red">AOF重写也是由主线程通过fork创建了子进程来完成的。</span>**   

16.以下哪些情况会引起Redis的主线程阻塞？ 

* **Redis 3.0中，删除一个100万元素的Set集**
* **AOF写回策略配置为everysec，同时`no-appendfsync-on-rewrite`设置为no**
* **200万个键值对同时过期**
* 一个服务读为主负载的Redis实例，已保存的数据量为1GB，正在创建RDB快照 


> 选项A，**会引起阻塞，Redis 3.0时还没有异步删除机制** 
> 
> 选项B, **AOF重写和AOF写回会竞争磁盘IO资源，导致AOF写回被阻塞，进而导致主线程也被阻塞** 
> 
> 选项C，**大量键值对同时过期会引发主线程阻塞**
> 
> 选项D, RDB由子进程生成，而且实例服务的是读为主的负载，没有内存的COW压力，不会阻塞 

**这个配置项设置为 yes 时，表示在 AOF 重写时，不进行 fsync 操作。也就是说，Redis 实例把写命令写到内存后，不调用后台线程进行 fsync 操作，就可以直接返回了。这个配置项设置为 no（也是默认配置），在 AOF 重写时，Redis 实例仍然会调用后台线程进行 fsync 操作，这就会给实例带来阻塞。**

17.RDB和AOF是Redis使用的两种持久化机制，关于这两种机制，下面的哪些描述是正确的？ 

* **<span style="color:red">使用RDB进行实例恢复的速度，要比使用AOF 进行恢复的速度快认</span>** 
* RDB的生成和AOF的日志记录都是通过子进程来完成的
* AOF文件记录的操作日志过多时，为了避免文件 过大，需要手动删除失效的操作日志 
* **<span style="color:red">Redis 4.0版本中可以使用RDB做快照，同时使 用AOF记录两次快照间的操作日志</span>** 


> 选项B, **AOF日志记录是由主线程完成的**
> 
> 选项C, **AOF重写机制可以自动清理AOF文件，不用手动清理** 


18.我们可以使用Hash和Sorted Set组合来保存时间序列数据，以下哪些功能可以使用这种方式直接在Redis实例上完成？ 

* 计算某个时间范围内的数据最大值 
* **<span style="color:red">查询某个时刻的数据</span>**
* **<span style="color:red">查询某个时间范围内的所有数据</span>** 
* **<span style="color:red">查询最新时刻的数据</span>** 

> **无法直接在Redis实例上完成，需要把数据读取到客户端，然后再进行计算**


19.Redis的Hash数据类型，是采用以下哪两种结构作为它的底层实现的？ 

* 整数数组 
* 双向链表 
* **哈希表** 
* **压缩列表**


> A选项，是Set类型的底层结构 
> 
> B选项，是List类型的底层结构 
> 
> CD正确


20.关于Redis Cluster，下面哪个描述是正确的？ 

* **Redis Cluster一共有16384个哈希槽**
* 使用Redis Cluster时，客户端不用记录哈希槽的任何信息，可以直接通过哈希计算，确定键值对在哪个实例 
* **Redis Cluster属于可扩展集群，主要用途是让Redis数据库能够保存更多数据认** 
* Redis Cluster中的实例只能通过持久化机制进行可靠性保证 

> 选项B，**客户端需要缓存哈希槽和实例的对应关系，无法直接通过哈希计算就知道数据在哪个实例，只能知道在哪个哈希槽** 
> 
> **D选项，Redis Cluster的实例也可以配置主从节点，进行可靠性保证**

## **2、主观题**

### **2-1 第一题**

Redis 在接收多个网络客户端发送的请求操作时，如果有一个客户端和 Redis 的网络连接断开了，Redis 会一直等待该客户端恢复连接吗？为什么？

答案：

Redis 不会等待客户端恢复连接。原因是，**Redis 的网络连接是由操作系统进行处理的，操作系统内核负责监听网络连接套接字上的连接请求或数据请求，而 Redis 采用了 IO 多路复用机制 epoll，不会阻塞在某一个特定的套接字上**。

**epoll 机制监测到套接字上有请求到达时，就会触发相应的事件，并把事件放到一个队列中，Redis 就会对这个事件队列中的事件进行处理**。这样一来，Redis 只用查看和处理事件队列，就可以了。

**当客户端网络连接断开或恢复时，操作系统会进行处理，并且在客户端能再次发送请求时，把接收到的请求以事件形式通知 Redis。**

### **2-2 第二题**

Redis 的主从集群可以提升数据可靠性，主节点在和从节点进行数据同步时，会使用两个缓冲区：复**制缓冲区和复制积压缓冲区。这两个缓冲区的作用各是什么？会对 Redis 主从同步产生什么影响吗？**

Redis 的主从集群可以提升数据可靠性，主节点在和从节点进行数据同步时，会使用两个缓冲区：复制缓冲区和复制积压缓冲区。这两个缓冲区的作用各是什么？会对 Redis 主从同步产生什么影响吗？

**首先来说一下复制缓冲区。**

作用：**主节点开始和一个从节点进行全量同步时，会为从节点创建一个输出缓冲区，这个缓冲区就是复制缓冲区。**

当主节点向从节点发送 RDB 文件时，如果**又接收到了写命令操作，就会把它们暂存在复制缓冲区中**。等 RDB 文件传输完成，并且在从节点加载完成后，主节点再把复制缓冲区中的写命令发给从节点，进行同步。

**对主从同步的影响**：

**如果主库传输 RDB 文件以及从库加载 RDB 文件耗时长，同时主库接收的写命令操作较多，就会导致复制缓冲区被写满而溢出。**

一旦溢出，主库就会关闭和从库的网络连接，重新开始全量同步。**所以，我们可以通过调整 `client-output-buffer-limit slave` 这个配置项，来增加复制缓冲区的大小，以免复制缓冲区溢出**。

再来看看复制积压缓冲区。

**作用**：**主节点和从节点进行常规同步时，会把写命令也暂存在复制积压缓冲区中。如果从节点和主节点间发生了网络断连，等从节点再次连接后，可以从复制积压缓冲区中同步尚未复制的命令操作。**


**对主从同步的影响**：如果从节点和主节点间的网络断连时间过长，复制积压缓冲区可能被新写入的命令覆盖。此时，**从节点就没有办法和主节点进行增量复制了，而是只能进行全量复制。针对这个问题，应对的方法是调大复制积压缓冲区的大小**（可以参考[第六节 数据同步：主从库数据一致](https://chao-xi.github.io/jxredisbook/chap2/6redis_master_slave_replicate/)`repl_backlog_size` 的设置）。


### **2-3 第三题**

假设在业务场景中，我们有 20GB 的短视频属性信息（包括短视频 ID、短视频基本信息，例如短视频作者、创建时间等）要持久化保存，并且线上负载以读为主，需要能快速查询到这些短视频信息。

现在，针对这个需求，我们想使用 Redis 来解决，请你来设计一个解决方案。我来提几个问题，你可以思考下。

首先，你会用 Redis 的什么数据类型来保存数据？如果我们只用单个实例来运行的话，你会采用什么样的持久化方案来保证数据的可靠性？

另外，如果不使用单实例运行，我们有两个备选方案：一个是用两台 32GB 内存的云主机来运行主从两个 Redis 实例；另一个是用 10 台 8GB 的云主机来运行 Redis Cluster，每两台云主机分别运行一个 Redis 实例主库和从库，分别保存 4GB 数据，你会用哪种方案呢？请聊一聊你的想法。

答案：

**Redis 的 Hash 类型属于典型的集合类型，可以保存 `key-value` 形式的数据。而且，当 Hash 类型中保存较多数据时，它的底层是由哈希表实现的。**

**哈希表的存取复杂度是 O(1)，所以可以实现快速访问。**

在这道题中，短视频属性信息属于典型 key-value 形式，所以，我们可以使用 Hash 类型保存短视频信息。具体来说，就是将一个短视频 ID 作为 Hash 集合的 key，将短视频的其他属性信息作为 Hash 集合内部的键值对，例如“作者”:“实际姓名”，“创建时间”:“实际时间”。这样既满足了保存数据的需求，也可以利用 Hash 快速查询的特点，快速查到相应的信息。

Redis 的 AOF 日志会记录客户端发送给实例的每一次写操作命令，在 Redis 实例恢复时，可以通过重新运行 AOF 文件中的命令，实现恢复数据的目的。在这道题的业务场景中，负载以读为主，因此，写命令不会太多，AOF 日志文件的体量不会太大，即使实例故障了，也可以快速完成恢复。所以，当使用单实例运行时，我们可以使用 AOF 日志来做持久化方案。

关于使用多实例的运行方案：两种方案各有优势，我们来分析一下。

**方案一**

优势：可以节省云主机数量和成本。虽然主从节点进行第一次全量同步时，RDB 文件较大，耗时会长些，但是因为写请求少，**所以复制缓冲区的压力不大**。

不足：如果网络环境不好，需要频繁地进行全量同步的话，这种方案的优势就小了，每次全量同步时的 RDB 生成和传输压力都很大。

**方案二**

优势：每个实例只用保存 4GB 数据，和从库同步时的压力较小。而且，这种方案的可扩展性更好，如果有新增数据，可以更好地应对。

不足：需要较多的云主机，运维和资源成本较高。

## **3、期末选择题**

1.在秒杀场景下，你可以在下面哪个环节应用Redis? 

* 前端静态页面缓存 
* **<span style="color:red">秒杀商品库存查询和扣减</span>** 
* 拦截恶意攻击的请求 
* 数据库订单异常处理 

2.对于切片集群来说，数据倾斜是需要关注的问题，以下哪些原因会引起数据倾斜？ 

* **存在bigkey** 
* RDB快照的生成 
* **数据分布不均衡** 
* **HashTag的使用** 

> RDB快照和数据倾斜没有关系
> bigkey 导致倾斜 / Slot 分配不均衡导致倾斜 / Hash Tag 导致倾斜 
> 
> [数据分布优化应对数据倾斜](https://chao-xi.github.io/jxredisbook/chap7/5redis_data_incline/)

3.关于Redis 6.0的ACL控制机制的描述，哪些是不正确 

* ACL支持不同用户用不同密码登录 
* **<span style="color:red">ACL只支持按一类命令的粒度设置访问规则</span>**
* ACL可以禁止客户端调用所有命令操作 
* **<span style="color:red">ACL使用短横线一和key前缀的key 来表示控制访问</span>** 


> 选项B, ACL支持对单个命令设置访问控制规则 
> 
> 选项D,ACL使用波浪线设置被访问控制的key 
> 
> 使用波浪号“~”和 key 的前缀来表示控制访问的 key。例如，我们执行下面命令，就可以设置用户 normaluser 只能对以“user:”为前缀的 key 进行命令操作：
> 
> `ACL SETUSER normaluser ~user:* +@all`

4.Redis 6.0开始支持多IO线程，关于多IO线程的描述，以下哪个说法是正确的 

* 多IO线程可以并行执行GET、SET等请求操作 
* Redis 6.0中默认启用了多IO线程 
* **<span style="color:red">可以使用io-threads配置项设置多线程的个数</span>**
* 可以使用io-threads-enable来启用或关闭多线程机制 


> 设置线程个数。一般来说，线程个数要小于 Redis 实例所在机器的 CPU 核个数，例如，对于一个 8 核的机器来说，Redis 官方建议配置 6 个 IO 线程。

`io-threads  6`

> A选项，**多IO线程只是处理网络请求解析** 
>
> B选项，**默认是关闭的**
> 
> 
> D选项，**使用`io-threads-do-reads`配置项启停多IO线程** 


5.当使用RESP 2协议的客户端想要使用Redis 6.0中推出的客户端缓存功能，可以使用以下哪种模式？ 

* direct 
* **redirect** 
* broadcast 
* 普通模式

> 普通模式和广播模式，需要客户端使用 RESP 3 协议，RESP 3 协议是 6.0 新启用的通信协议
> 
> 对于使用 RESP 2 协议的客户端来说，就需要使用另一种模式，也就是重定向模式（redirect）。

6.NVM是近年来存储设备发展的一个大变化，会对Redis等系统软件产生巨大影响，以下哪个特性不是非易失存储器件具备的特性？ 

* 读延迟和DRAM一样 
* **写延迟接近DRAM** 
* 可以持久化保存数据 
* 密度大，容量大 

> 选项A，正确，**NVM读延迟要高于DRAM，选项答案不是NVM特性** 
> 
> 选项B，属于NVM特性 
> 
> 选项C，属于NVM特性 
> 
> 选项D，属于NVM特性 

7.为了保证数据在主从库间的一致性，**我们需要将数据的过期时间设置为绝对时间**，可以使用以下哪些命令来进行设置？ 

* EXPIRE
* PEXIRE
* **EXPIREAT**
* **PEXPIREAT** 

> EXPIRE 和 PEXPIRE：它们给数据设置的是从命令执行时开始计算的存活时间；
> 
> **EXPIRE / PEXIRE 该命令设置相对过期时间**
> 
> EXPIREAT 和 PEXPIREAT：它们会直接把数据的过期时间设置为具体的一个时间点。

[什么会导致读取到过期数据](https://chao-xi.github.io/jxredisbook/chap7/1Redis_master_slave/#2-3)

8.下面这些关于Redis事务机制的描述，哪些是正确的？ 

* Redis事务可以保证原子性
* **<span style="color:red">Redis事务可以保证一致性</span>**
* Redis事务不能保证隔离性 
* **<span style="color:red">Redis事务无法保证持久性</span>**

> 选项A,**Redis在事务中有命令语法错误时，无法保证原子性，其他情况可以保证** 
> 
> **选项C, Redis事务可以保证隔离性** 


9.假设一个客户端的ID号是100，该客户端想使用名为mylock的key作为锁变量，并设置锁变量的过期时间是10s，请问应该使用以下哪个命令来进行加锁操作？ 

* SET mylock 100 PX 10 
* SET mylock 100 PX 10000 
* **<span style="color:red">SET mylock 100 NX EX 10</span>** 
* SET mylock 10 NX EX 100 


> 如果使用了 NX 选项，SET 命令只有在键值对不存在时，才会进行设置，否则不做赋值操作。此外，SET 命令在执行时还可以带上 EX 或 PX 选项，用来设置键值对的过期时间。
> 
> 举个例子，执行下面的命令时，只有 key 不存在时，SET 才会创建 key，并对 key 进行赋值。另外，key 的存活时间由 seconds 或者 milliseconds 选项值来决定。
> 
> `SET key value [EX seconds | PX milliseconds]  [NX]`
> 
> 有了 SET 命令的 NX 和 EX/PX 选项后，我们就可以用下面的命令来实现加锁操作了。
> 
> `SET lock_key unique_value NX PX 10000`

> **选项A, PX的单位是毫秒，设置的过期时间不对** 
> 
> 选项B，**没有使用NX选项，如果mylock的key本身不存在，那么该命令也不会创建key，导致加锁失败** 
> 
> 选项D, **EX的值应该是10, mylock的值应该是100** 

10.假设我们将Redis的`min-slaves-to-write`配置项设置为1, 哨兵的`down-after-milliseconds`设置为`15s`, 哨兵主从切换需要`5s`。主库因为某些原因卡住了`18s`，那 么，`mIn-slaves-max-lag`设置为多少时，可以避免脑裂？ 

* **15**
* **16**
* 23
* 33

> 选项C，**旧主库18s后恢复正常，此时还没有超出23s，而且哨兵还没有切换完成，导致旧主库可能接收写请求**
> 
> 选项D，**旧主库18s后恢复正常，此时没有超出33s，而且哨兵还没有切换完成，导致旧主库可能接收写请求** 


**`min-slaves-max-lag`：这个配置项设置了主从库间进行数据复制时，从库给主库发送 ACK 消息的最大延迟（以秒为单位）。**


11.假设有一个业务应用想使用如下代码实现分布式锁，你觉得，这段代码有什么问题吗？ 

```
SETNX lock_key 1
DO THINGS
DEL lock_key
```

* **<span style="color:red">没有对锁变量设置过期时间,会导致锁可能一直被持有</span>**
* 应该使用SET命令加上NX选项 
* `lock_key`这个键值对的键名称应该改为客户端的唯一ID
*  **<span style="color:red">锁变量可能被并发的客户端释放掉</span>**


> 选项B，SETNX和SET NX的效果是一样的
> 
>  选项C，需要把`lock_key`键值对的值改为客户端唯一ID，而不是把键改为唯一ID 

12.假设有多个客户端同时读取键值对a、b的值，并对键值对c的值做加1操作，下面哪些代码片段能保证数据的正确性？ 

```
A.
GET a
GET b
INC c

B.
以下 5 句使用 Lua 脚本实现
GET a
GET b
GET c
c = c + 1
SET c

C.
GET a
GET b
// 以下三句用 Lua 脚本实现
GET c
c = c + 1
SET c

D.
GET a
GET b
// 以下两句用 Lua 脚本实现
GET c
c = c + 1
SET c
```

> 选项A，正确，INCR命令原子执行，可以保证数据正确性 
> 
> 选项B，正确，Lua脚本原子执行，可以保证数据正确性，但是没有必要把GET a和b也放到脚本中 
> 
> 选项C，正确 
> 
> 选项D,	SET c需要和读取c，以及c做加一操作一起执行 

13.Pika是一个基于SSD实现的大容量键值数据库，下面这些关于Pika的说法中，有哪些是正确的？ 

* Pika虽然可以实现大容量存储，但是数据类型和 Redis不兼容 
* **<span style="color:red">Pika内部使用RocksDB来保存落盘的数据</span>**
* **<span style="color:red">Pika使用多线程来处理客户端请求</span>**
* pika使用binlog机制实现写命令的增量同步和Redis一样，仍然会受内存缓冲区的大小限制 

> A选项，**Pika支持兼容Redis的5大基本数据类型** 
> 
> D选项，**Pika主从同步时，不受缓存区大小限制了** 


14.下面这些关于Codis集群的描述，哪些是正确的？ 

*  Codis集群默认使用16384个Slot进行key的分配
* 为了保证迁移数据的完整性，Codis只支持同步迁移 
* **<span style="color:red">Codis proxy接收客户端请求，并进行请求转发</span>** 
* **<span style="color:red">Codis集群可以使用etcd保存集群元数据</span>** 


> A选项，**Codis默认使用1024个Slot** 
> 
> B选项，Codis支持异步迁移，是为了避免阻塞主线程 

15.当Redis用作缓存时，如果同时有**大量数据失效**，那么此时会发生什么问题？ 

* 缓存击穿 
* 缓存穿透 
* **<span style="color:red">缓存雪崩</span>** 
* 没有问题 


> A选项，**击穿是表示单个或少量热点数据失效** 
> 
> B选项，**穿透是指访问的数据既不在缓存，也不在数据库** 
> 
> C选项，正确 
> 
> D选项，**题干条件下，会发生缓存雪崩，导致大量请求发送到数据库层，给数据库层带来压力** 


16.在使用Redis作为缓存时，**如果有一个应用的负载是对一个大数据集中的所有数据扫描一遍**，那么使用下面哪种数据淘汰策略会更加合适？ 

* allkeys-lru 
* **<span style="color:red">allkeys-Ifu</span>** 
* allkeys-random 
* noeviction 

> A选项，**该策略按数据访问时效性进行筛选，会导致刚被访问的数据滞留在缓存，无法被及时淘汰，造成缓存污染** 
> 
> B选项，正确 
> 
> C选项，该策略随机选取淘汰的数据，会造成缓存污染 
> 
> D选项，该策略不会淘汰数据 

* LFU 缓存策略是在 LRU 策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。
* LRU 算法的全称是 Least Recently Used，从名字上就可以看出，这是按照最近最少使用的原则来筛选数据，最不常用的数据会被筛选出来，而最近频繁使用的数据会留在缓存中


17.在应用Redis切片集群时，使用了Hash Tag对数据进行切片，现有数据的key是`user:info:{330}`, value是1024，请问切片集群使用数据的哪一部分内容计算CRC 值？ 

* user:info:{330} 
* 1024 
* **330**
* info 

> 题目解析 使用Hash Tag时，**Redis只会使用花括号内的内容计算CRC值**，所以选C，其他选项都不是花括号内的内容。 

18.当Redis用作只读缓存时，如果数据发生了修改，以下哪 个说法是正确的？ 

* 通过先删除缓存值，后更新数据库值，就可以避免 数据不一致问题 
* 通过先更新数据库，再删除缓存，就可以避免数据 不一致问题x
* 在先删除缓存值，后更新数据库时操作,  如果有并发读操作，可以使用重试数据库更新操作，避免数据不一致
* **在先删除缓存值，后更新数据库时，如果有并发读，可以使用延迟双删，来应对数据不一致问题** 


> 选项A，**删除缓存后，如果数据库没有更新成功，就会导致数据不一致** 
> 
> 选项B，**更新数据库后，如果缓存删除失败，就会导致仍然读到旧值** 
> 
> 选项C，**重试数据库更新操作是在数据库更新失败情况下的应对方案** 
> 
> 选项D，正确 

19.Redis缓存一旦发生缓存击穿，就会导致大量请求发送到 数据库层进行处理，可能会导致数据库压力过大而崩溃， 以下哪些方法可以应对缓存击穿问题，缓解数据库压力？ 

* 给数据的过期时间增加随机量，避免同时过期 
* **数据库限流** 
* 在业务应用接入层检查是否有恶意请求 
* **不给热点数据设置过期时间** 

> A选项，该选项方法是用来应对缓存雪崩的，解决不了击穿问题 
> 
> B选项，正确，可以避免压垮数据库 
> 
> C选项，该选项方法是用来应对缓存穿透的 
> 
> D选项，正确 

**击穿是表示单个或少量热点数据失效** 

20.以下哪个命令不属于Redis事务机制所需的关键命令？ 

* MULTI 
* **SET**
* EXEC
* DISCARD 

> A选项，是事务机制的关键命令，表示事务开始 
>
> B选项，正确，**这是用来设置key的value值的命令，不属于事务机制的必需命令** 
> 
> C选项，是事务机制的关键命令，让实例开始实际执行事务 
> 
> D选项，是事务机制的关键命令，表示撤销事务操作  

